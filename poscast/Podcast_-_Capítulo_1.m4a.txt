

Olá e bem-vinda, bem-vindo. Hoje a gente tem na mesa o primeiro capítulo de um livro que está dando o que falar, o Modern Angler, do A. E a nossa proposta é bem ambiciosa, viu? Decifrar o que estão chamando de Renascimento do Engler. A ideia aqui não é só listar as novidades, mas entender a jornada. Por que o Angular, que é um framework tão estabelecido, precisou se reinventar de uma forma tão profunda? Exatamente. O capítulo 1 funciona quase como um manifesto, sabe? Ele olha para trás, para aquelas dores que todo desenvolvedor Angular mais experiente conhece bem, para poder justificar a direção que o framework está tomando hoje. É assim, uma tentativa de responder aquela pergunta que pairava no ar. O Engler estava ficando complexo demais.


E a resposta que o livro dá é um sim. E a gente fez algo. a respeito. E é isso que a gente vai desvendar. Mergulhar no material do Army of Lithuania para entender que problemas eram esses. Como a comunidade ajudou a moldar as soluções. E o mais importante, qual é a sensação de começar um projeto com essa nova filosofia? A missão é sair daqui com um mapa mental bem claro do que significa angular moderno. Um mapa que, como o livro deixa claro, está sendo desenhado para ser muito mais fácil de ler. especialmente para quem está chegando agora. Certo, vamos começar por aí, então. O passado. Para a gente poder apreciar o novo, a gente precisa lembrar do antigo, né? O livro descreve o ângulo como ele sempre foi.


foi poderoso, robusto, opinativo, mas com uma curva de aprendizado que podia ser, digamos, um pouco intimidadora. O que o autor aponta como os principais vilões dessa complexidade toda? Olha, o livro é bem direto. Ele aponta para três pilares que sustentavam o framework. mas que também geravam muito atrito. O primeiro, e talvez o mais famoso, eram os Endimódios, a arquitetura baseada em módulos. Eles eram a cola universal, a peça que organizava tudo. Cola e, muitas vezes, a fonte da dor de cabeça. Eu lembro de projetos onde depurar um provider que estava no módulo errado, nossa, consumia horas. dias às vezes. Era quase um rito de passagem entender a diferença entre providers e exports e por que uma coisa funcionava num feature model, mas no outro não. Exato.


O livro menciona justamente isso, a gestão daquela famosa trindade de módulos, sabe? Shared, Core e Feature. Era uma arte. Para quem estava começando, era uma barreira conceitual enorme. E para equipes grandes, era uma fonte constante de código repetitivo, o famoso boilerplate. E de decisões de arquitetura que, se fossem feitas erradas lá no início, cobravam um preço muito alto mais tarde. E não era só a estrutura, né? A forma como a gente escrevia o código também tinha suas rigidezas. Sem dúvida, esse é o segundo pilar que o capítulo critica, a forte ligação com a programação orientada a objetos, a OOP. Quase tudo no Angular era uma class. componentes, serviços, pipes, guards, tudo. E isso forçava a injeção de dependência a acontecer só através dos construtores. Funcionava, claro.


Fica bem claro quando o autor usa o exemplo de uma aplicação de RH, um sistema HMS. Ele desenha um diagrama com módulos para funcionários, recrutamento, folha de pagamento. E você quase sente o peso da estrutura. Dá para imaginar os N modules todos interligados e as hierarquias de classes só de olhar para o esquema. de atrito era mais sutil, mas igualmente impactante, que era a detecção de mudanças. O livro explica que todo o mecanismo dependia de uma biblioteca de terceiros a zone.js, para, tipo, magicamente saber quando a interface precisava ser atualizada. O problema é que essa mágica tinha um custo, né? A verificação era por padrão global, percorria toda a árvore de componentes de cima para baixo. Em aplicações grandes e complexas isso podia virar um gargalo de performance bem significativo.


Quem nunca se deparou com um bug de detecção de mudanças que só acontecia porque uma biblioteca de terceiros rodava fora da energy zone, né? Era outro rito de passagem. Então o cenário era esse. Módulos complexos, a rigidez da orientação a objetos e uma detecção de mudanças que podia ser bem ineficiente. O palco estava montado para uma mudança. Exatamente. A complexidade não era só teórica. Era um obstáculo prático que afetava a produtividade, manutenção e até a capacidade do framework de atrair novos talentos. E é aqui que a história fica real. realmente interessante. O livro deixa muito claro que essa transformação não foi um decreto do time do Google. Não foi algo que aconteceu assim, a portas fechadas. Pelo contrário, né? Foi um processo super aberto, colaborativo.


Sim, e dedicar uma sessão inteira para isso no primeiro capítulo é uma declaração e tanto. O autor detalha o processo de RFC, o Request for Comments. É uma metodologia que mostra um amadurecimento imenso do framework. A ideia de que uma mudança significativa pode começar com uma issue aberta no GitHub por qualquer pessoa da comunidade. Isso é muito poderoso. É fascinante porque quebra aquela imagem de que a equipe do Angular vive numa torre de marfim. Então, uma ideia surge, seja interna ou da comunidade, qual é o caminho que ela percorre? Olha, o caminho é longo. e cheio de filtros de qualidade. Primeiro tem uma fase de exploração interna. Depois, um documento RFC formal é escrito. bem detalhado com o problema, a solução proposta, a API, tudo.


Esse documento é revisado pela equipe principal, por Google Developer Experts, Só aí ele se torna público, convidando toda a comunidade a dar feedback, a criticar, a sugerir melhorias. Ou seja, antes mesmo de uma linha de código ser escrevida. Escrita, a ideia já foi debatida e refinada abertamente. Isso evita aquelas situações de lançar uma feature que ninguém pediu. Precisamente. comunidade é positivo, a funcionalidade é implementada e entra num estágio de Developer Preview. É um beta público para as pessoas testarem em projetos reais, mas não em produção. Claro, só depois de passar por todo esse escrutínio e provar o seu valor é que a funcionalidade se torna estável. O livro enfatiza que as grandes mudanças como o Signals passaram por esse processo super rigoroso.


E isso se conecta diretamente com outra fonte de informação que o capítulo menciona, a pesquisa anual, a Angular Developer Survey. Eles estão literalmente Literalmente perguntando para os desenvolvedores, onde dói mais? E eles ouvem. O livro deixa claro que os objetivos do Angular Moderno são uma resposta direta a essas dores. Primeiro objetivo, facilitar a adoção para novos desenvolvedores, atacando de frente a barreira dos NG módulos. O segundo. Reduzir o código repetitivo, o boilerplate. E o terceiro, melhorar a reatividade e a segurança de tipos, principalmente nos formulários reativos, que era uma das áreas mais criticadas. Então, esse renascimento é menos uma revolução imposta de cima para baixo e mais uma evolução dialogada. A equipe está atuando como uma curadora das melhores ideias, não importa de onde elas venham, para guiar o framework numa direção que a própria comunidade está pedindo.


É a melhor definição. Uma evolução guiada pela comunidade com um processo transparente para garantir que as mudanças sejam robustas e bem-vindas. Ok. Então a gente entendeu o passado e o processo. Agora, a parte que todo mundo espera. Como isso tudo se traduz na prática? O capítulo nos leva pelo processo de criar uma aplicação nova com a CLI. E a experiência é diferente. A primeira coisa que se nota é o que não está lá. Exato. O momento uau para qualquer desenvolvedor que vem das versões antigas é quando você roda NG New e abre a pasta do projeto. E o livro destaca isso como o ponto de virada. Não existe mais um arquivo app.module.ts. Para muita gente, isso é quase um choque cultural. É o fim de uma era.


Anos e anos organizando tudo em volta daquele arquivo e, de repente, ele some. E o que assume o lugar dele? Como é que a aplicação sabe como começar? A responsabilidade que era do módulo agora é do próprio componente. O AppComponent, que é o componente raiz da aplicação, agora vem com uma propriedade nova no decorador. Standalone. True. Essa pequena linha de código muda tudo. Significa que o componente se torna autossuficiente. Ele mesmo gerencia as próprias dependências. Então, ao invés de declarar um CommonModule ou RouterModule lá no EnergyModule, eu declaro isso direto no componente que vai usar. Exatamente. Dentro do decorador do AppComponent, agora existe um array chamado Imports. E ali você coloca o que ele precisa, como o RouterOutlet, por exemplo. A indireção foi removida. O que o componente usa está declarado no próprio componente.


Fica muito mais fácil de rastrear as dependências. Mas e as configurações globais? Coisas como provedores de serviços que deveriam estar disponíveis para a aplicação inteira ou a configuração das rotas. Isso antes vivia no app model. Para onde foi? Essa lógica foi movida para um lugar mais apropriado. O livro apresenta um novo arquivo, o app.config.ts. Ele exporta uma constante chamada Application Config. É ali que a gente define o arquivo. Define esses provedores globais como o Provider Router com as rotas da aplicação. É uma separação de responsabilidades muito mais clara. Configuração fica em Arquivo de Configuração. E a inicialização da aplicação no main.ts também deve ter mudado, imagino. Mudou completamente. A antiga função BootstrapModule, que recebia o app Module, foi substituída pela BootstrapApplication. E aí Essa nova função recebe duas coisas.


O componente raiz, nosso Web Component Standalone, e, opcionalmente, essa nova Application Config. É muito mais direto. Sabe, isso me lembra uma analogia. Antes, era como se o seu componente principal viesse numa caixa, mas o manual de instruções, o end módulo, viesse num livreto separado, que você precisava consultar para saber como montar e que ferramentas usar. Agora, é como se na própria caixa do componente já viesse uma lista clara. Para funcionar, eu preciso destas três ferramentas, que já estão ali dentro. É bem mais intuitivo. Perfeita analogia. E isso levanta uma questão que eu vejo muito na comunidade. Essa simplificação não pode levar ao caos em projetos grandes sem a estrutura real. rígida dos enigmódulos para forçar uma organização, a gente não corre o risco de ter projetos virando um emaranhado de dependências importadas em todo lugar?


O livro aborda esse receio? É um ponto importante. O livro não aborda isso diretamente nesse capítulo inicial, mas a filosofia por trás dos componentes stand-alone sugere uma resposta. A ideia é que a organização agora se baseia na funcionalidade, não em agrupadores artificiais. Você pode ter barrel files, aqueles index.ts que exportam rotas ou provedores de uma feature, e você importa esse pacote de configuração onde for necessário. A organização ainda é crucial, só que agora ela é mais explícita e menos baseada na mágica dos módulos. Faz sentido. A responsabilidade da boa arquitetura passa a ser mais explícita do desenvolvedor em vez de ser implicitamente delegada a uma estrutura do framework. Então, essa mudança para Standalone não é só sobre deletar um arquivo. É a fundação para todo o resto do Angular moderno.


O livro usa isso como um trampolim para apresentar as outras grandes novidades. Sim, o capítulo funciona como um trailer para o resto do livro. Ele mostra que uma vez que você remove a dependência dos energy modules e das classes para tudo, um novo mundo de possibilidades se abre. Cada nova feature é apresentada como uma solução direta para um daqueles problemas que a gente discutiu no início. Certo. Então, com os componentes Standalone como base, o que mais é desbloqueado? Bom, a primeira consequência direta é uma injeção de dependência revitalizada. O livro introduz a função Inject. Como não estamos mais presos a construtores de classes para tudo, essa função permite que você injete dependências em qualquer contexto de injeção, como dentro de outras funções.


Isso abre portas para um código muito mais funcional e para a criação de lógicas reutilizáveis de um jeito que era bem verboso antes. Ah, então é por isso. Uma coisa leva à outra. Se os componentes se libertam da rigidez dos módulos, a injeção de dependência também precisa se libertar da rigidez dos construtores de classe. Exatamente. E a próxima grande novidade que o livro apresenta são os signals. Eles são a resposta direta do Angular ao problema da detecção de mudanças ineficiente e a complexidade de gerenciar estado reativo. É o novo primitivo reativo do framework projetado para ser muito mais simples de usar e para permitir uma detecção de mudanças bem granular, que atualiza só o que realmente mudou, eliminando a necessidade da zone.js na maioria dos casos.


E, finalmente, o capítulo menciona a nova sintaxe de template, com os blocos at if e at for. Imagino que isso também seja uma consequência, né? Sem end módulos, importar diretivas como end if e end for em todo componente se tornaria repetitivo. Perfeito. A nova sintaxe de fluxo de controle é built-in, faz parte da própria template, não precisa importar nada. Isso torna os templates mais legíveis, mais perfeitos. e de novo, reduz o boilerplate. Cada uma dessas novidades, inject, signals, a nova sintaxe se apoia na fundação que os componentes stand-alone criaram. O que eu acho muito sensato é que o livro também faz questão de dizer o que não mudou. Não é uma terra arrasada. Eles não estão jogando fora todo o legado do Angular.


E essa é talvez a parte mais importante para adoção em larga escala. O capítulo reforça o compromisso total com a compatibilidade retroativa. Equipes com aplicações gigantescas baseadas em end modules não são forçadas a reescrever tudo. Elas podem migrar gradualmente um componente de cada vez. O suporte ao TypeScript continua sendo o pilar central do framework e o suporte ao RxDS também permanece. do RxJS no Angular. O livro esclarece que não. O RGS continua sendo uma ferramenta incrivelmente poderosa para lidar com eventos complexos e assíncronos, especialmente com o fluxo de dados. O que está mudando é a forma como ele interage com o framework. Signals são ideais para valores que mudam com o tempo e se conectam à interface, enquanto o RxS brilha na orquestração de eventos. Eles são complementares, sabe?


É uma evolução do ecossistema reativo, não uma substituição. Resumindo então, o primeiro capítulo de Modern Angler pinta um quadro muito claro. O framework passou por uma introspecção profunda, ouviu as dores da comunidade e se reconstruiu sobre uma base de simplicidade e foco na experiência do desenvolvedor. A transição para o modelo Standalone não é só uma feature, é a chave que destravou todas as outras modernizações. É uma narrativa de amadurecimento. O Angular está se livrando do excesso de bagagem que acumulou ao longo dos anos para se tornar mais ágil, mais acessível, sem perder a robustez que sempre foi sua marca registrada. Ele estabelece o contexto, o problema e o início da solução de forma muito eficaz. E isso nos leva a uma reflexão final que o próprio livro parece provocar.


se o renascimento do Angular, essa jornada em direção à simplificação e à opcionalidade. A provocação que fica, e que certamente vai ser explorada no resto do livro, é, à medida que um conceito tão fundamental como o Zen de modules se torna opcional, o que isso realmente nos diz sobre a identidade futura do Angular? Será que a gente está testemunhando uma transição para um modelo mais funcional, mais à la carte, onde se monta o framework com as peças que se precisa, de forma parecida com outros concorrentes no mercado? E se for isso, que outros conceitos que hoje a gente considera essenciais no Angular poderiam se tornar opcionais amanhã? Essa é a questão que fica no ar.